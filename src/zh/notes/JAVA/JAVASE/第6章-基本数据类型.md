---
title: 第6章_基本数据类型
category:
  - JAVA
tag: 
  - JAVASE
date: 2023-03-03
---

<!-- more -->

## 1、基本类型

字符型：char

布尔型：boolean

数值类型：

1. 整型：byte、short、int、long
2. 浮点型：float、double

String不是基本数据类型，是引用类型。

---

## 2、整型的取值范围

Java中的整型主要包含byte、short、int和long这四种，表示的数字范围也是从小到大的，之所以表示范围不同主要和他们存储数据时所占的字节数有关。

1字节=8位（bit）。java中的整型属于有符号数。

8bit可以表示的数字：

- 最小值：10000000 （-128）(-2^7)
- 最大值：01111111（127）(2^7-1)

整型取值如下：

- byte：byte用1个字节来存储，范围为-128(-2^7)到127(2^7-1)，在变量初始化的时候，byte类型的默认值为0。
- short：short用2个字节存储，范围为-32,768(-2^15)到32,767(2^15-1)，在变量初始化的时候，short类型的默认值为0，一般情况下，因为Java本身转型的原因，可以直接写为0。
- int：int用4个字节存储，范围为-2,147,483,648(-2^31)到2,147,483,647(2^31-1)，在变量初始化的时候，int类型的默认值为0。
- long：long用8个字节存储，范围为-9,223,372,036,854,775,808(-2^63)到9,223,372,036,854,775,807(2^63-1)，在变量初始化的时候，long类型的默认值为0L或0l，也可直接写为0。

超出范围怎么办？

整型中，每个类型都有一定的表示范围，但是，在程序中有些计算会导致超出表示范围，即溢出。如以下代码：

```java
int i = Integer.MAX_VALUE;
int j = Integer.MAX_VALUE;
 
int k = i + j;
System.out.println("i (" + i + ") + j (" + j + ") = k (" + k + ")");
```

输出结果：i (2147483647) + j (2147483647) = k (-2)

这就是发生了溢出，溢出的时候并不会抛异常，也没有任何提示。所以，在程序中，使用同类型的数据进行运算的时候，一定要注意数据溢出的问题。

---

## 3、浮点数

我们知道，计算机的数字的存储和运算都是通过二进制进行的，对于，十进制整数转换为二进制整数采用"除2取余，逆序排列"法

具体做法是：

- 用2整除十进制整数，可以得到一个商和余数；
- 再用2去除商，又会得到一个商和余数，如此进行，直到商为小于1时为止
- 然后**把先得到的余数作为二进制数的低位有效位，后得到的余数作为二进制数的高位有效位**，依次排列起来。

如，我们想要把127转换成二进制，做法如下：

![image-20230303131505217](https://studyimages.oss-cn-beijing.aliyuncs.com/img/JAVASE/Base/202303031315316.png)

那么，十进制小数转换成二进制小数，又该如何计算呢？

十进制小数转换成二进制小数采用"乘2取整，顺序排列"法。

具体做法是：

- 用2乘十进制小数，可以得到积
- 将积的整数部分取出，再用2乘余下的小数部分，又得到一个积
- 再将积的整数部分取出，如此进行，直到积中的小数部分为零，此时0或1为二进制的最后一位。或者达到所要求的精度为止。

如尝试将0.625转成二进制：

![image-20230303131557393](https://studyimages.oss-cn-beijing.aliyuncs.com/img/JAVASE/Base/202303031315456.png)

但是0.625是一个特列，用同样的算法，请计算下0.1对应的二进制是多少：

![image-20230303131606466](https://studyimages.oss-cn-beijing.aliyuncs.com/img/JAVASE/Base/202303031316554.png)

我们发现，0.1的二进制表示中出现了无限循环的情况，也就是(0.1)10 = (0.000110011001100…)2

这种情况，计算机就没办法用二进制精确的表示0.1了。

所以，为了解决部分小数无法使用二进制精确表示的问题，于是就有了IEEE 754规范。

IEEE二进制浮点数算术标准（IEEE 754）是20世纪80年代以来最广泛使用的浮点数运算标准，为许多CPU与浮点运算器所采用。

**浮点数和小数并不是完全一样的，计算机中小数的表示法，其实有定点和浮点两种。因为在位数相同的情况下，定点数的表示范围要比浮点数小。所以在计算机科学中，使用浮点数来表示实数的近似值**。


IEEE 754规定了四种表示浮点数值的方式：单精确度（32位）、双精确度（64位）、延伸单精确度（43比特以上，很少使用）与延伸双精确度（79比特以上，通常以80位实现）。

其中最常用的就是32位单精度浮点数和64位双精度浮点数。

- 单精度浮点数在计算机存储器中占用4个字节（32 bits），利用“浮点”（浮动小数点）的方法，可以表示一个范围很大的数值。
- 比起单精度浮点数，双精度浮点数(double)使用 64 位（8字节） 来存储一个浮点数。

IEEE并没有解决小数无法精确表示的问题，只是提出了一种使用近似值表示小数的方式，并且引入了精度的概念。

一个浮点数a由两个数m和e来表示：`a = m × b^e`。

在任意一个这样的系统中，我们选择一个基数b（记数系统的基）和精度p（即使用多少位来存储）。m（即尾数）是形如±d.ddd...ddd的p位数（每一位是一个介于0到b-1之间的整数，包括0和b-1)。

如果m的第一位是非0整数,m称作规格化的。有一些描述使用一个单独的符号位(s 代表+或者-）来表示正负，这样m必须是正的。e是指数。 

规格化又叫规格化数，是一种表示浮点数的规格化的表示方法，经过规格化的浮点数叫作规格化数。

最后，由于计算机中保存的小数其实是十进制的小数的近似值，并不是精确值，所以，千万不要在代码中使用浮点数来表示金额等重要的指标。**建议使用BigDecimal或者Long(单位为分)来表示金额**。

---

## 4、JAVA中负数的绝对值并不一定是正数

在Java中，想要获得一个数字的绝对值，可以使用java.lang.Math中的abs方法，这个类共有四个重载的abs方法，分别是：
```java
public static int abs(int a) {
    return (a < 0) ? -a : a;
}
 
public static long abs(long a) {
    return (a < 0) ? -a : a;
}
 
public static float abs(float a) {
    return (a <= 0.0F) ? 0.0F - a : a;
}
 
 public static double abs(double a) {
    return (a <= 0.0D) ? 0.0D - a : a;
}
 
```
以上四个方法分别返回int、long、float、double类型的绝对值，方法中的逻辑也简单，无非就是遇到整数就直接返回，遇到负数就取相反数返回。 

比如，我们基于订单号实现分库分表，但订单号是字符串类型，我们需要取得这个字符串的hashCode，因为hashCode值可能是负数，所以对hashCode取绝对值，再用这个值对分表数取模：
Math.abs(orderId.hashCode)%1024;

但是，上面的逻辑是有问题的。因为在极特殊情况下，上面的代码会得到一个负数值。

这种极特殊情况就是当hashCode是Integer.MIN_VALUE时，即整数能表达的最小值时。下面通过代码进行验证：
```java
public static void main(String[] args){
    Sout(Math.abs(Integer.MIN_VALUE));
}
```
执行以上代码，结果如下：-2147483648

很明显，这是负数！这要从Integer的取值范围说起，int的取值范围是：-2^31 ---- 2^31-1 ,即：-2147483648 - 2147483647，当我们使用abs取绝对值时，取得-2147483648 绝对值是2147483648 。即超过了int的取值范围。这时就会发生越界。

如何解决这个问题呢？

把这个int类型的值转为long类型,这样就不会发生越界啦！
```
public static void main(String[] args){
    Sout(Math.abs((long)Integer.MIN_VALUE));
}
```

一定要记得，对long类型的数值取绝对值其实也可能存在这个情况，只不过发生的概率更低啦！